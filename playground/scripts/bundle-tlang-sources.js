/**
 * Bundle tlang source files into a static TypeScript module
 *
 * This script reads all TypeScript files from ../src/ and generates a module
 * that exports them as string constants. This allows the playground to be
 * completely static and deployable without a backend server.
 *
 * Usage: node scripts/bundle-tlang-sources.js
 */

import { readFileSync, writeFileSync, readdirSync, statSync, mkdirSync } from 'fs'
import { join, relative, dirname } from 'path'
import { fileURLToPath } from 'url'
import ts from 'typescript'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const TLANG_SRC_DIR = join(__dirname, '../../src')
const TLANG_INDEX_PATH = join(TLANG_SRC_DIR, 'index.ts')
const TLANG_PACKAGE_JSON_PATH = join(__dirname, '../../package.json')
const OUTPUT_FILE = join(__dirname, '../src/generated/tlangSources.ts')

/**
 * Recursively get all .ts files from a directory
 */
function getAllTsFiles(dir, fileList = []) {
  const files = readdirSync(dir)

  files.forEach(file => {
    const filePath = join(dir, file)
    const stat = statSync(filePath)

    if (stat.isDirectory()) {
      getAllTsFiles(filePath, fileList)
    } else if (file.endsWith('.ts')) {
      fileList.push(filePath)
    }
  })

  return fileList
}

/**
 * Escape string for TypeScript template literal
 */
function escapeForTemplate(str) {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$')
}

/**
 * Extract top-level exports from @atools/tlang/src/index.ts
 * Returns array of export names (e.g., ['Omit', 'Pick', 'Partial', ...])
 */
function extractTopLevelExports() {
  const content = readFileSync(TLANG_INDEX_PATH, 'utf-8')
  const sourceFile = ts.createSourceFile(
    'index.ts',
    content,
    ts.ScriptTarget.Latest,
    true
  )

  const topLevelExports = []

  // Visit all export declarations
  sourceFile.statements.forEach(statement => {
    if (ts.isExportDeclaration(statement) && statement.moduleSpecifier) {
      if (statement.exportClause && ts.isNamedExports(statement.exportClause)) {
        // export type { A, B, C } from './file'
        statement.exportClause.elements.forEach(element => {
          topLevelExports.push(element.name.text)
        })
      }
    }
  })

  return topLevelExports.sort()
}

/**
 * Main bundling logic
 */
function bundleTLangSources() {
  console.log('üì¶ Bundling @atools/tlang sources...')

  // Read real package.json from @atools/tlang
  const tlangPackageJson = JSON.parse(readFileSync(TLANG_PACKAGE_JSON_PATH, 'utf-8'))
  console.log(`‚úÖ Read package.json: ${tlangPackageJson.name}@${tlangPackageJson.version}`)

  // Extract top-level exports from index.ts
  const topLevelExports = extractTopLevelExports()
  console.log(`‚úÖ Extracted ${topLevelExports.length} top-level exports`)

  // Get all TypeScript files
  const tsFiles = getAllTsFiles(TLANG_SRC_DIR)
  console.log(`Found ${tsFiles.length} TypeScript files`)

  // Build the sources map
  const sourcesMap = {}

  tsFiles.forEach(filePath => {
    const content = readFileSync(filePath, 'utf-8')
    const relativePath = relative(TLANG_SRC_DIR, filePath)

    // Convert to virtual path format: /node_modules/@atools/tlang/core/index.ts
    const virtualPath = `/node_modules/@atools/tlang/${relativePath.replace(/\\/g, '/')}`

    sourcesMap[virtualPath] = content
  })

  // Generate package.json for VFS (using real data from @atools/tlang)
  // For TypeScript VFS, we need to point to .ts files, not .js
  const vfsPackageJson = {
    name: tlangPackageJson.name,
    version: tlangPackageJson.version,
    description: tlangPackageJson.description,
    main: './index.ts',  // VFS needs source .ts files
    types: './index.ts',
    exports: {
      '.': './index.ts',
      './*': './*'
    }
  }

  // Generate TypeScript module
  const moduleContent = `/**
 * Auto-generated @atools/tlang source files bundle
 *
 * This file is generated by scripts/bundle-tlang-sources.js
 * DO NOT EDIT MANUALLY - it will be overwritten
 *
 * Source: @atools/tlang@${tlangPackageJson.version}
 * Generated at: ${new Date().toISOString()}
 */

export const TLANG_SOURCES: Record<string, string> = {
${Object.entries(sourcesMap).map(([path, content]) => {
  return `  '${path}': \`${escapeForTemplate(content)}\`,`
}).join('\n\n')}
}

/**
 * Top-level exports from @atools/tlang/src/index.ts
 *
 * Auto-extracted from index.ts - Single Source of Truth
 * These are types exported directly, not in namespaces
 */
export const TLANG_TOP_LEVEL_EXPORTS: readonly string[] = ${JSON.stringify(topLevelExports)} as const

/**
 * Package.json for tlang module resolution in TypeScript VFS
 *
 * Auto-generated from real @atools/tlang/package.json
 * Main and types point to .ts files for VFS compatibility
 */
export const TLANG_PACKAGE_JSON = ${JSON.stringify(JSON.stringify(vfsPackageJson, null, 2))}

/**
 * Load tlang sources into a virtual file system map
 */
export function loadTLangIntoVFS(fsMap: Map<string, string>): void {
  // Add all source files
  for (const [path, content] of Object.entries(TLANG_SOURCES)) {
    fsMap.set(path, content)
  }

  // Add package.json
  fsMap.set('/node_modules/@atools/tlang/package.json', TLANG_PACKAGE_JSON)
}
`

  // Ensure output directory exists
  mkdirSync(dirname(OUTPUT_FILE), { recursive: true })

  // Write the module
  writeFileSync(OUTPUT_FILE, moduleContent, 'utf-8')

  console.log(`‚úÖ Generated ${OUTPUT_FILE}`)
  console.log(`   Bundled ${Object.keys(sourcesMap).length} files`)
}

// Run the bundler
try {
  bundleTLangSources()
} catch (error) {
  console.error('‚ùå Failed to bundle tlang sources:', error)
  process.exit(1)
}
