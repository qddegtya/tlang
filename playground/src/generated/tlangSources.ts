/**
 * Auto-generated tlang source files bundle
 *
 * This file is generated by scripts/bundle-tlang-sources.js
 * DO NOT EDIT MANUALLY - it will be overwritten
 *
 * Generated at: 2025-12-29T15:39:21.090Z
 */

export const TLANG_SOURCES: Record<string, string> = {
  '/node_modules/tlang/core/index.ts': `/**
 * Type-level Flow-Based Programming
 *
 * Core FBP principles at the type level:
 * - Multiple inputs, multiple outputs per node
 * - Graph-based execution (DAG only, no cycles)
 * - Port-first architecture: connections are Port → Port
 *
 * Philosophy:
 * - Everything is a node with ports
 * - Data flows through port connections
 * - Manual orchestration for DAG execution
 */

/**
 * Port - A named input or output channel on a node
 *
 * In FBP, ports are the connection points where data packets flow.
 * Each port has a name and carries a specific type.
 */
export type Port<Name extends string = string, Type = unknown> = {
  name: Name
  type: Type
}

/**
 * Node - The fundamental unit in FBP
 *
 * All nodes have:
 * - inputs: Record of input port values
 * - outputs: Record of output port values
 * - nodeInputs symbol for value injection
 *
 * Single-port nodes are just nodes with { in } → { out }
 * Multi-port nodes have multiple named inputs/outputs
 */
export declare const nodeInputs: unique symbol
export type nodeInputs = typeof nodeInputs

export interface Node {
  [nodeInputs]: unknown
  inputs: Record<string, unknown>
  outputs: Record<string, unknown>
}

/**
 * Exec - Execute a node and get all output ports
 *
 * @template N - Node to execute
 * @template Inputs - Input ports { portName: value }
 * @returns Output ports { portName: value }
 *
 * @example
 * Exec<DoubleNode, { in: 5 }>          // { out: 10 }
 * Exec<AddNode, { a: 2, b: 3 }>        // { sum: 5 }
 */
export type Exec<
  N extends Node,
  Inputs extends Record<string, unknown>
> = (N & { [nodeInputs]: Inputs })['outputs']

/**
 * Out - Extract value from an output port
 *
 * @template Outputs - Output ports from Exec
 * @template PortName - Port name to extract
 *
 * @example
 * Out<Exec<DoubleNode, { in: 5 }>, 'out'>  // 10
 */
export type Out<
  Outputs extends Record<string, unknown>,
  PortName extends keyof Outputs
> = Outputs[PortName]

/**
 * Pipe - Chain single-port nodes sequentially
 *
 * Syntax sugar for connecting nodes with { in } → { out } ports.
 *
 * @template Input - Initial value
 * @template Nodes - Array of nodes to chain
 *
 * @example
 * Pipe<5, [DoubleNode, IncrementNode]>  // 11
 */
export type Pipe<Input, Nodes extends readonly unknown[]> =
  Nodes extends readonly [infer First extends Node, ...infer Rest]
    ? Pipe<Out<Exec<First, { in: Input }>, 'out'>, Rest>
    : Input

/**
 * Connection - Describes how ports are wired together
 *
 * In FBP, connections define the graph topology:
 * - from: Source node and port
 * - to: Destination node and port
 */
export type Connection = {
  from: { node: string; port: string }
  to: { node: string; port: string }
}

/**
 * Network - DAG of interconnected nodes
 *
 * Supports:
 * - Branching: one output to multiple inputs
 * - Merging: multiple outputs to one input
 *
 * Does NOT support:
 * - Cycles: TypeScript circular type limitation
 *
 * @template Nodes - Map of node names to node instances
 * @template Connections - Array of connections defining the graph
 * @template InitialData - Initial packets to inject into the network
 */
export type Network<
  Nodes extends Record<string, Node>,
  Connections extends readonly Connection[],
  InitialData extends Record<string, unknown>
> = {
  nodes: Nodes
  connections: Connections
  initial: InitialData
}

/**
 * Implementation Notes:
 *
 * TypeScript cannot auto-execute DAG networks due to circular type limitations.
 * Use manual orchestration with Exec + Out for complex graphs.
 *
 * Why Pipe works: linear dependency chain
 * Why DAG doesn't: circular dependencies lose literal types
 *
 * Solution: Manual composition
 * - Exec<Node, Inputs> → outputs
 * - Out<Outputs, Port> → value
 */
`,

  '/node_modules/tlang/index.ts': `/**
 * tlang
 *
 * Visual type system powered by Flow-Based Programming
 *
 * Core Philosophy:
 * - Types flow through nodes like data in FBP
 * - Each node is a pure function at the type level
 * - Pipe = sequential node execution
 * - Exec + Out = manual DAG orchestration
 *
 * @example
 * import type { Pipe, Omit, Pick } from 'tlang'
 *
 * type User = { id: number; email: string; password: string }
 *
 * type PublicUser = Pipe<User, [
 *   Omit<'password'>,
 *   Pick<'id' | 'email'>
 * ]>
 * // Result: { id: number; email: string }
 */

// Core FBP primitives
export type { Node, Exec, Out, Pipe, nodeInputs, Network, Connection } from './core'

// Basic transformation nodes
export type {
  Omit,
  Pick,
  Partial,
  Required,
  Readonly,
  Extend
} from './nodes/basic'

// Conditional flow control
export type {
  Identity
} from './nodes/conditional'

// Deep recursive transformations
export type {
  DeepPartial,
  DeepReadonly,
  DeepRequired
} from './nodes/deep'

// Union type operations
export type {
  UnionKeys,
  UnionToIntersection,
  ExcludeUnion,
  ExtractUnion,
  UnionMap
} from './nodes/union'

// Union namespace
export * as Unions from './nodes/union'

// Tuple operations
export * as Tuples from './nodes/tuples'

// String operations
export * as Strings from './nodes/strings'

// Object advanced operations
export * as Objects from './nodes/objects'

// Number operations
export * as Numbers from './nodes/numbers'

// Boolean operations
export * as Booleans from './nodes/booleans'

// Match pattern matching
export * as Match from './nodes/match'

// Functions utilities
export * as Functions from './nodes/functions'
`,

  '/node_modules/tlang/nodes/arithmetic.ts': `/**
 * Arithmetic nodes for multi-port network operations
 *
 * These demonstrate the power of FBP-style multi-input nodes
 * compared to HotScript's single-parameter approach
 */

import type { Node, nodeInputs } from '../core'

// Helper: Build tuple of specific length (tail recursive)
type BuildTuple<N extends number, Acc extends unknown[] = []> =
  Acc['length'] extends N
    ? Acc
    : BuildTuple<N, [...Acc, unknown]>

/**
 * AddNode - Two-input addition node
 *
 * This is the FBP way: multiple named inputs!
 * Key: outputs is a simple property whose VALUE is an object type
 */
export interface AddNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [this[nodeInputs]['a'], this[nodeInputs]['b']] extends [infer A extends number, infer B extends number]
    ? { sum: [...BuildTuple<A>, ...BuildTuple<B>]['length'] & number }
    : never
}

export interface DoubleNode extends Node {
  [nodeInputs]: { in: number }
  inputs: { in: number }
  outputs: this[nodeInputs]['in'] extends infer N extends number
    ? { out: [...BuildTuple<N>, ...BuildTuple<N>]['length'] & number }
    : never
}

export interface IncrementNode extends Node {
  [nodeInputs]: { in: number }
  inputs: { in: number }
  outputs: this[nodeInputs]['in'] extends infer N extends number
    ? { out: [...BuildTuple<N>, unknown]['length'] & number }
    : never
}

/**
 * SplitNode - One input, multiple outputs
 *
 * Shows how FBP nodes can have multiple outputs
 */
export interface SplitNode extends Node {
  [nodeInputs]: { value: number }
  inputs: { value: number }
  outputs: this[nodeInputs] extends { value: infer V extends number }
    ? {
        original: V
        doubled: [...BuildTuple<V>, ...BuildTuple<V>]['length'] & number
      }
    : never
}
`,

  '/node_modules/tlang/nodes/basic.ts': `/**
 * Basic type transformation nodes
 *
 * Single-port nodes with { in } → { out } structure
 */

import type { Node, nodeInputs } from '../core'

/**
 * OmitNode - Removes specified keys
 *
 * @example
 * Exec<Omit<'password'>, { in: User }>  // { out: SafeUser }
 */
export interface OmitNode<Keys extends PropertyKey> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Omit<T, Keys> }
    : never
}

/**
 * PickNode - Selects specified keys
 */
export interface PickNode<Keys extends PropertyKey> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Pick<T, Keys & keyof T> }
    : never
}

/**
 * PartialNode - Makes properties optional
 */
export interface PartialNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Partial<T> }
    : never
}

/**
 * RequiredNode - Makes properties required
 */
export interface RequiredNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Required<T> }
    : never
}

/**
 * ReadonlyNode - Makes properties readonly
 */
export interface ReadonlyNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Readonly<T> }
    : never
}

/**
 * ExtendNode - Adds properties
 */
export interface ExtendNode<Extension> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: T & Extension }
    : never
}

/**
 * Exported node constructors
 */
export type Omit<Keys extends PropertyKey> = OmitNode<Keys>
export type Pick<Keys extends PropertyKey> = PickNode<Keys>
export type Partial = PartialNode
export type Required = RequiredNode
export type Readonly = ReadonlyNode
export type Extend<Extension> = ExtendNode<Extension>
`,

  '/node_modules/tlang/nodes/booleans.ts': `/**
 * Boolean operations
 *
 * Type-level boolean logic operations
 */

import type { Node, nodeInputs } from '../core'

/**
 * AndNode - Logical AND of two booleans
 *
 * @example
 * type Result = Exec<AndNode, { a: true, b: true }>
 * // { result: true }
 */
export interface AndNode extends Node {
  [nodeInputs]: { a: boolean; b: boolean }
  inputs: { a: boolean; b: boolean }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends boolean, infer B extends boolean]
    ? { result: A extends true ? (B extends true ? true : false) : false }
    : never
}

/**
 * OrNode - Logical OR of two booleans
 *
 * @example
 * type Result = Exec<OrNode, { a: true, b: false }>
 * // { result: true }
 */
export interface OrNode extends Node {
  [nodeInputs]: { a: boolean; b: boolean }
  inputs: { a: boolean; b: boolean }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends boolean, infer B extends boolean]
    ? { result: A extends true ? true : (B extends true ? true : false) }
    : never
}

/**
 * NotNode - Logical NOT
 *
 * @example
 * type Result = Exec<NotNode, { in: true }>
 * // { out: false }
 */
export interface NotNode extends Node {
  [nodeInputs]: { in: boolean }
  inputs: { in: boolean }
  outputs: this[nodeInputs]['in'] extends infer B extends boolean
    ? { out: B extends true ? false : true }
    : never
}

/**
 * EqualsNode - Check if two booleans are equal
 *
 * @example
 * type Result = Exec<EqualsNode, { a: true, b: true }>
 * // { result: true }
 */
export interface EqualsNode extends Node {
  [nodeInputs]: { a: boolean; b: boolean }
  inputs: { a: boolean; b: boolean }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends boolean, infer B extends boolean]
    ? { result: A extends B ? true : false }
    : never
}

/**
 * XorNode - Logical XOR (exclusive or)
 *
 * @example
 * type Result = Exec<XorNode, { a: true, b: false }>
 * // { result: true }
 */
export interface XorNode extends Node {
  [nodeInputs]: { a: boolean; b: boolean }
  inputs: { a: boolean; b: boolean }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends boolean, infer B extends boolean]
    ? { result: A extends B ? false : true }
    : never
}

/**
 * Exported node constructors
 */
export type And = AndNode
export type Or = OrNode
export type Not = NotNode
export type Equals = EqualsNode
export type Xor = XorNode
`,

  '/node_modules/tlang/nodes/conditional.ts': `/**
 * Conditional type transformation nodes
 *
 * Implements branching logic in type flows, similar to if-else statements
 * but at the type level.
 */

import type { Node, nodeInputs } from '../core'

/**
 * IdentityNode - Returns input type unchanged
 *
 * Useful as a no-op node or default branch in conditionals.
 *
 * @example
 * type Same<T> = Flow<T, [Identity]>
 * // T → T (no change)
 */
export interface IdentityNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: T }
    : never
}

/**
 * Exported identity node
 */
export type Identity = IdentityNode
`,

  '/node_modules/tlang/nodes/deep.ts': `/**
 * Deep transformation nodes
 *
 * Apply transformations recursively through nested object structures.
 * These nodes traverse the entire type tree and apply transformations
 * at every level.
 */

import type { Node, nodeInputs } from '../core'

/**
 * DeepPartialNode - Recursively makes all properties optional
 *
 * Unlike standard Partial which only affects top-level properties,
 * this node makes ALL nested properties optional as well.
 *
 * @example
 * type User = {
 *   profile: {
 *     name: string
 *     settings: { theme: string }
 *   }
 * }
 * type PartialUser = Flow<User, [DeepPartial]>
 * // Result: {
 * //   profile?: {
 * //     name?: string
 * //     settings?: { theme?: string }
 * //   }
 * // }
 */
export interface DeepPartialNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends object
      ? { out: { [P in keyof T]?: DeepPartialImpl<T[P]> } }
      : { out: T }
    : never
}

type DeepPartialImpl<T> = T extends object
  ? { [P in keyof T]?: DeepPartialImpl<T[P]> }
  : T

/**
 * DeepReadonlyNode - Recursively makes all properties readonly
 *
 * Makes the entire type tree immutable, not just the top level.
 *
 * @example
 * type Config = {
 *   api: {
 *     endpoint: string
 *     timeout: number
 *   }
 * }
 * type ImmutableConfig = Flow<Config, [DeepReadonly]>
 * // All levels become readonly
 */
export interface DeepReadonlyNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends object
      ? { out: { readonly [P in keyof T]: DeepReadonlyImpl<T[P]> } }
      : { out: T }
    : never
}

type DeepReadonlyImpl<T> = T extends object
  ? { readonly [P in keyof T]: DeepReadonlyImpl<T[P]> }
  : T

/**
 * DeepRequiredNode - Recursively makes all properties required
 *
 * Removes all optional modifiers at every level of the type tree.
 *
 * @example
 * type User = {
 *   profile?: {
 *     name?: string
 *   }
 * }
 * type RequiredUser = Flow<User, [DeepRequired]>
 * // All '?' removed at all levels
 */
export interface DeepRequiredNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends object
      ? { out: { [P in keyof T]-?: DeepRequiredImpl<T[P]> } }
      : { out: T }
    : never
}

type DeepRequiredImpl<T> = T extends object
  ? { [P in keyof T]-?: DeepRequiredImpl<T[P]> }
  : T

/**
 * Exported node constructors
 */
export type DeepPartial = DeepPartialNode
export type DeepReadonly = DeepReadonlyNode
export type DeepRequired = DeepRequiredNode
`,

  '/node_modules/tlang/nodes/functions.ts': `/**
 * Functions utilities
 *
 * Type-level utilities for function types
 */

import type { Node, nodeInputs } from '../core'

/**
 * AnyFunction - Type alias for function types
 */
type AnyFunction = (...args: never[]) => unknown

/**
 * ParametersNode - Extract function parameters
 *
 * @example
 * type Result = Exec<ParametersNode, { in: (a: number, b: string) => void }>
 * // { out: [a: number, b: string] }
 */
export interface ParametersNode extends Node {
  [nodeInputs]: { in: AnyFunction }
  inputs: { in: AnyFunction }
  outputs: this[nodeInputs]['in'] extends infer F extends AnyFunction
    ? F extends (...args: infer P) => unknown
      ? { out: P }
      : never
    : never
}

/**
 * ReturnTypeNode - Extract function return type
 *
 * @example
 * type Result = Exec<ReturnTypeNode, { in: (a: number) => string }>
 * // { out: string }
 */
export interface ReturnTypeNode extends Node {
  [nodeInputs]: { in: AnyFunction }
  inputs: { in: AnyFunction }
  outputs: this[nodeInputs]['in'] extends infer F extends AnyFunction
    ? F extends (...args: never[]) => infer R
      ? { out: R }
      : never
    : never
}

/**
 * MapReturnTypeNode - Transform return type of a function
 *
 * @template Fn - Node to apply to return type
 *
 * @example
 * type Result = Exec<MapReturnTypeNode<ToStringNode>, {
 *   in: (a: number) => 1 | 2
 * }>
 * // { out: (a: number) => "1" | "2" }
 */
export interface MapReturnTypeNode<Fn extends Node> extends Node {
  [nodeInputs]: { in: AnyFunction }
  inputs: { in: AnyFunction }
  outputs: this[nodeInputs]['in'] extends infer F extends AnyFunction
    ? F extends (...args: infer P) => infer R
      ? {
          out: (...args: P) => (Fn & { [nodeInputs]: { in: R } })['outputs']['out']
        }
      : never
    : never
}

/**
 * ConstantNode - Always return a constant value
 *
 * @template Value - Constant value to return
 *
 * @example
 * type Result = Exec<ConstantNode<42>, { in: unknown }>
 * // { out: 42 }
 */
export interface ConstantNode<Value> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: { out: Value }
}

/**
 * Exported node constructors
 */
export type Parameters = ParametersNode
export type ReturnType = ReturnTypeNode
export type MapReturnType<Fn extends Node> = MapReturnTypeNode<Fn>
export type Constant<Value> = ConstantNode<Value>
`,

  '/node_modules/tlang/nodes/match.ts': `/**
 * Match pattern matching
 *
 * Type-level pattern matching with extractors
 */

import type { Node, nodeInputs } from '../core'

/**
 * With clause - pattern and handler pair
 */
export type With<Pattern, Handler extends Node> = {
  pattern: Pattern
  handler: Handler
}

/**
 * DoesMatch - Check if value matches pattern
 */
type DoesMatch<Value, Pattern> = Value extends Pattern ? true : false

/**
 * MatchNode - Pattern matching with multiple clauses
 *
 * @example
 * type Result = Exec<MatchNode<[
 *   With<string, AppendNode<': is string'>>,
 *   With<number, ToStringNode>,
 *   With<unknown, ConstantNode<'unknown'>>
 * ]>, { in: 'hello' }>
 * // { out: 'hello: is string' }
 */
export interface MatchNode<Clauses extends readonly With<unknown, Node>[]> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer Value
    ? { out: MatchImpl<Value, Clauses> }
    : never
}

type MatchImpl<Value, Clauses extends readonly With<unknown, Node>[]> =
  Clauses extends readonly [
    With<infer Pattern, infer Handler extends Node>,
    ...infer Rest extends readonly With<unknown, Node>[]
  ]
    ? DoesMatch<Value, Pattern> extends true
      ? (Handler & { [nodeInputs]: { in: Value } })['outputs']['out']
      : MatchImpl<Value, Rest>
    : never

/**
 * Exported node constructor
 */
export type Match<Clauses extends readonly With<unknown, Node>[]> = MatchNode<Clauses>
`,

  '/node_modules/tlang/nodes/numbers.ts': `/**
 * Numbers operations
 *
 * Type-level number arithmetic using tuple length manipulation
 * Supports literal number types for compile-time computation
 */

import type { Node, nodeInputs } from '../core'

// ========================================
// Helper: Build tuple of length N
// ========================================

type BuildTuple<N extends number, Acc extends unknown[] = []> =
  Acc['length'] extends N ? Acc : BuildTuple<N, [...Acc, unknown]>

// ========================================
// Arithmetic Operations
// ========================================

/**
 * AddNode - Add two numbers
 *
 * @example
 * type Result = Exec<AddNode, { a: 2, b: 3 }>
 * // { sum: 5 }
 */
export interface AddNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { sum: [...BuildTuple<A>, ...BuildTuple<B>]['length'] & number }
    : never
}

/**
 * SubNode - Subtract two numbers
 *
 * @example
 * type Result = Exec<SubNode, { a: 5, b: 3 }>
 * // { diff: 2 }
 */
export interface SubNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? BuildTuple<A> extends [...BuildTuple<B>, ...infer Rest]
      ? { diff: Rest['length'] & number }
      : { diff: 0 }
    : never
}

/**
 * MulNode - Multiply two numbers
 *
 * @example
 * type Result = Exec<MulNode, { a: 3, b: 4 }>
 * // { product: 12 }
 */
export interface MulNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { product: MulHelper<A, B> }
    : never
}

type MulHelper<A extends number, B extends number, Acc extends unknown[] = []> =
  B extends 0
    ? Acc['length'] & number
    : B extends 1
      ? [...Acc, ...BuildTuple<A>]['length'] & number
      : MulHelper<A, SubOne<B>, [...Acc, ...BuildTuple<A>]>

type SubOne<N extends number> =
  BuildTuple<N> extends [unknown, ...infer Rest]
    ? Rest['length'] & number
    : 0

/**
 * DivNode - Divide two numbers (integer division)
 *
 * @example
 * type Result = Exec<DivNode, { a: 10, b: 3 }>
 * // { quotient: 3 }
 */
export interface DivNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { quotient: DivHelper<A, B> }
    : never
}

type DivHelper<A extends number, B extends number, Count extends unknown[] = []> =
  B extends 0
    ? never  // Division by zero
    : A extends 0
      ? Count['length'] & number
      : BuildTuple<A> extends [...BuildTuple<B>, ...infer Rest]
        ? DivHelper<Rest['length'] & number, B, [...Count, unknown]>
        : Count['length'] & number

/**
 * ModNode - Modulo operation
 *
 * @example
 * type Result = Exec<ModNode, { a: 10, b: 3 }>
 * // { remainder: 1 }
 */
export interface ModNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { remainder: ModHelper<A, B> }
    : never
}

type ModHelper<A extends number, B extends number> =
  B extends 0
    ? never  // Division by zero
    : A extends 0
      ? 0
      : BuildTuple<A> extends [...BuildTuple<B>, ...infer Rest]
        ? ModHelper<Rest['length'] & number, B>
        : A

/**
 * NegateNode - Negate a number (not supported at type level, returns 0)
 *
 * Note: TypeScript literal types don't support negative numbers well
 */
export interface NegateNode extends Node {
  [nodeInputs]: { in: number }
  inputs: { in: number }
  outputs: { out: 0 }  // Placeholder: negative numbers aren't well supported
}

/**
 * AbsNode - Absolute value (identity for positive numbers)
 */
export interface AbsNode extends Node {
  [nodeInputs]: { in: number }
  inputs: { in: number }
  outputs: this[nodeInputs]['in'] extends infer N extends number
    ? { out: N }
    : never
}

// ========================================
// Comparison Operations
// ========================================

/**
 * MaxNode - Return maximum of two numbers
 */
export interface MaxNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { max: CompareHelper<A, B> extends 1 ? A : B }
    : never
}

/**
 * MinNode - Return minimum of two numbers
 */
export interface MinNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { min: CompareHelper<A, B> extends -1 ? A : B }
    : never
}

/**
 * CompareNode - Compare two numbers
 * Returns: -1 if a < b, 0 if a === b, 1 if a > b
 */
export interface CompareNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { result: CompareHelper<A, B> }
    : never
}

type CompareHelper<A extends number, B extends number> =
  A extends B
    ? 0
    : BuildTuple<A> extends [...BuildTuple<B>, ...unknown[]]
      ? 1
      : -1

/**
 * EqualNode - Check if two numbers are equal
 */
export interface EqualNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { result: A extends B ? true : false }
    : never
}

/**
 * LessThanNode - Check if a < b
 */
export interface LessThanNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { result: CompareHelper<A, B> extends -1 ? true : false }
    : never
}

/**
 * GreaterThanNode - Check if a > b
 */
export interface GreaterThanNode extends Node {
  [nodeInputs]: { a: number; b: number }
  inputs: { a: number; b: number }
  outputs: [
    this[nodeInputs]['a'],
    this[nodeInputs]['b']
  ] extends [infer A extends number, infer B extends number]
    ? { result: CompareHelper<A, B> extends 1 ? true : false }
    : never
}

// ========================================
// Exported node constructors
// ========================================

export type Add = AddNode
export type Sub = SubNode
export type Mul = MulNode
export type Div = DivNode
export type Mod = ModNode
export type Negate = NegateNode
export type Abs = AbsNode
export type Max = MaxNode
export type Min = MinNode
export type Compare = CompareNode
export type Equal = EqualNode
export type LessThan = LessThanNode
export type GreaterThan = GreaterThanNode
`,

  '/node_modules/tlang/nodes/objects.ts': `/**
 * Objects advanced operations
 *
 * Higher-order object transformations
 */

import type { Node, nodeInputs } from '../core'

/**
 * MapValuesNode - Transform all values in an object
 *
 * @example
 * type Input = { a: 1, b: 2 }
 * type Outputs = Exec<MapValuesNode<DoubleNode>, { in: Input }>
 * // { out: { a: 2, b: 4 } }
 */
export interface MapValuesNode<Fn extends Node> extends Node {
  [nodeInputs]: { in: Record<string, unknown> }
  inputs: { in: Record<string, unknown> }
  outputs: this[nodeInputs]['in'] extends infer Obj extends Record<string, unknown>
    ? {
        out: {
          [K in keyof Obj]: (Fn & { [nodeInputs]: { in: Obj[K] } })['outputs']['out']
        }
      }
    : never
}

/**
 * MapKeysNode - Transform all keys in an object
 *
 * @example
 * type Input = { a: 1, b: 2 }
 * type Outputs = Exec<MapKeysNode<UppercaseNode>, { in: Input }>
 * // { out: { A: 1, B: 2 } }
 */
export interface MapKeysNode<Fn extends Node> extends Node {
  [nodeInputs]: { in: Record<string, unknown> }
  inputs: { in: Record<string, unknown> }
  outputs: this[nodeInputs]['in'] extends infer Obj extends Record<string, unknown>
    ? {
        out: {
          [K in keyof Obj as (Fn & { [nodeInputs]: { in: K } })['outputs']['out'] & string]: Obj[K]
        }
      }
    : never
}

/**
 * KeysNode - Get object keys as tuple
 */
export interface KeysNode extends Node {
  [nodeInputs]: { in: Record<string, unknown> }
  inputs: { in: Record<string, unknown> }
  outputs: this[nodeInputs]['in'] extends infer Obj extends Record<string, unknown>
    ? { out: (keyof Obj)[] }
    : never
}

/**
 * ValuesNode - Get object values as tuple
 */
export interface ValuesNode extends Node {
  [nodeInputs]: { in: Record<string, unknown> }
  inputs: { in: Record<string, unknown> }
  outputs: this[nodeInputs]['in'] extends infer Obj extends Record<string, unknown>
    ? { out: Obj[keyof Obj][] }
    : never
}

/**
 * EntriesNode - Convert object to entries
 */
export interface EntriesNode extends Node {
  [nodeInputs]: { in: Record<string, unknown> }
  inputs: { in: Record<string, unknown> }
  outputs: this[nodeInputs]['in'] extends infer Obj extends Record<string, unknown>
    ? {
        out: {
          [K in keyof Obj]: [K, Obj[K]]
        }[keyof Obj][]
      }
    : never
}

/**
 * FromEntriesNode - Convert entries to object
 */
export interface FromEntriesNode extends Node {
  [nodeInputs]: { in: readonly [PropertyKey, unknown][] }
  inputs: { in: readonly [PropertyKey, unknown][] }
  outputs: this[nodeInputs]['in'] extends infer Entries extends readonly [PropertyKey, unknown][]
    ? {
        out: {
          [E in Entries[number] as E extends [infer K extends PropertyKey, unknown]
            ? K
            : never]: E extends [PropertyKey, infer V] ? V : never
        }
      }
    : never
}

/**
 * Exported node constructors
 */
export type MapValues<Fn extends Node> = MapValuesNode<Fn>
export type MapKeys<Fn extends Node> = MapKeysNode<Fn>
export type Keys = KeysNode
export type Values = ValuesNode
export type Entries = EntriesNode
export type FromEntries = FromEntriesNode
`,

  '/node_modules/tlang/nodes/strings.ts': `/**
 * String transformation nodes for tlang
 *
 * Operations on string types for text manipulation at the type level.
 * Inspired by HotScript's Strings module.
 */

import type { Node, nodeInputs } from '../core'

/**
 * Stringifiable - Types that can be converted to string
 */
export type Stringifiable =
  | string
  | number
  | boolean
  | bigint
  | null
  | undefined

/**
 * LengthNode - Get the length of a string
 *
 * @example
 * type Result = Flow<"abc", [Strings.Length]>
 * // Result: 3
 *
 * @warning Does not work with emojis since they are multiple characters
 */
export interface LengthNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: LengthImpl<T> }
      : { out: never }
    : never
}

type LengthImpl<S extends string, Acc extends unknown[] = []> =
  S extends \`\${string}\${infer Rest}\`
    ? LengthImpl<Rest, [...Acc, unknown]>
    : Acc['length']

/**
 * SplitNode - Split a string into a tuple
 *
 * @template Sep - The separator to split on
 *
 * @example
 * type Result = Flow<"a,b,c", [Strings.Split<",">]>
 * // Result: ["a", "b", "c"]
 *
 * @warning Using empty separator with emojis will destroy the emoji
 */
export interface SplitNode<Sep extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: SplitImpl<T, Sep> }
      : { out: never }
    : never
}

type SplitImpl<S extends string, Sep extends string> =
  Sep extends ''
    ? StringToTuple<S>
    : S extends \`\${infer First}\${Sep}\${infer Rest}\`
      ? [First, ...SplitImpl<Rest, Sep>]
      : S extends ''
        ? []
        : [S]

/**
 * ToTupleNode - Convert string to tuple of characters
 *
 * @example
 * type Result = Flow<"abc", [Strings.ToTuple]>
 * // Result: ["a", "b", "c"]
 *
 * @warning Does not work with emojis since they are multiple characters
 */
export interface ToTupleNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: StringToTuple<T> }
      : { out: never }
    : never
}

type StringToTuple<S extends string, Acc extends string[] = []> =
  S extends \`\${infer First}\${infer Rest}\`
    ? StringToTuple<Rest, [...Acc, First]>
    : Acc

/**
 * ToStringNode - Convert stringifiable to string
 *
 * @example
 * type Result = Flow<123, [Strings.ToString]>
 * // Result: "123"
 */
export interface ToStringNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: \`\${Extract<T, Stringifiable>}\` }
    : never
}

/**
 * ToNumberNode - Convert string to number or bigint
 *
 * @example
 * type Result = Flow<"123", [Strings.ToNumber]>
 * // Result: 123
 */
export interface ToNumberNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends \`\${infer N extends number | bigint}\`
      ? { out: N }
      : { out: never }
    : never
}

/**
 * PrependNode - Prepend string to input
 *
 * @template Start - String to prepend
 *
 * @example
 * type Result = Flow<"def", [Strings.Prepend<"abc">]>
 * // Result: "abcdef"
 */
export interface PrependNode<Start extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: \`\${Start}\${Extract<T, Stringifiable>}\` }
    : never
}

/**
 * AppendNode - Append string to input
 *
 * @template End - String to append
 *
 * @example
 * type Result = Flow<"abc", [Strings.Append<"def">]>
 * // Result: "abcdef"
 */
export interface AppendNode<End extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: \`\${Extract<T, Stringifiable>}\${End}\` }
    : never
}

/**
 * UppercaseNode - Transform string to uppercase
 *
 * @example
 * type Result = Flow<"abc", [Strings.Uppercase]>
 * // Result: "ABC"
 */
export interface UppercaseNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Uppercase<Extract<T, string>> }
    : never
}

/**
 * LowercaseNode - Transform string to lowercase
 *
 * @example
 * type Result = Flow<"ABC", [Strings.Lowercase]>
 * // Result: "abc"
 */
export interface LowercaseNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Lowercase<Extract<T, string>> }
    : never
}

/**
 * CapitalizeNode - Capitalize first character
 *
 * @example
 * type Result = Flow<"abc", [Strings.Capitalize]>
 * // Result: "Abc"
 */
export interface CapitalizeNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Capitalize<Extract<T, string>> }
    : never
}

/**
 * UncapitalizeNode - Uncapitalize first character
 *
 * @example
 * type Result = Flow<"ABC", [Strings.Uncapitalize]>
 * // Result: "aBC"
 */
export interface UncapitalizeNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Uncapitalize<Extract<T, string>> }
    : never
}

/**
 * TrimNode - Trim whitespace from both sides
 *
 * @template Sep - Separator to trim (default: " ")
 *
 * @example
 * type Result = Flow<"  abc  ", [Strings.Trim]>
 * // Result: "abc"
 */
export interface TrimNode<Sep extends string = ' '> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: TrimImpl<T, Sep> }
      : { out: never }
    : never
}

type TrimImpl<S extends string, Sep extends string> =
  TrimLeftImpl<TrimRightImpl<S, Sep>, Sep>

type TrimLeftImpl<S extends string, Sep extends string> =
  S extends \`\${Sep}\${infer Rest}\`
    ? TrimLeftImpl<Rest, Sep>
    : S

type TrimRightImpl<S extends string, Sep extends string> =
  S extends \`\${infer Rest}\${Sep}\`
    ? TrimRightImpl<Rest, Sep>
    : S

/**
 * TrimLeftNode - Trim whitespace from left side
 *
 * @template Sep - Separator to trim (default: " ")
 *
 * @example
 * type Result = Flow<"  abc", [Strings.TrimLeft]>
 * // Result: "abc"
 */
export interface TrimLeftNode<Sep extends string = ' '> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: TrimLeftImpl<T, Sep> }
      : { out: never }
    : never
}

/**
 * TrimRightNode - Trim whitespace from right side
 *
 * @template Sep - Separator to trim (default: " ")
 *
 * @example
 * type Result = Flow<"abc  ", [Strings.TrimRight]>
 * // Result: "abc"
 */
export interface TrimRightNode<Sep extends string = ' '> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: TrimRightImpl<T, Sep> }
      : { out: never }
    : never
}

/**
 * ReplaceNode - Replace all occurrences of substring
 *
 * @template From - Substring to replace
 * @template To - Replacement string
 *
 * @example
 * type Result = Flow<"a.b.c", [Strings.Replace<".", "/">]>
 * // Result: "a/b/c"
 */
export interface ReplaceNode<From extends string, To extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: ReplaceImpl<T, From, To> }
      : { out: never }
    : never
}

type ReplaceImpl<S extends string, From extends string, To extends string> =
  From extends ''
    ? S
    : S extends \`\${infer Head}\${From}\${infer Tail}\`
      ? \`\${Head}\${To}\${ReplaceImpl<Tail, From, To>}\`
      : S

/**
 * RepeatNode - Repeat string N times
 *
 * @template N - Number of times to repeat
 *
 * @example
 * type Result = Flow<"abc", [Strings.Repeat<3>]>
 * // Result: "abcabcabc"
 */
export interface RepeatNode<N extends number> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: RepeatImpl<T, N> }
      : { out: never }
    : never
}

type RepeatImpl<
  S extends string,
  N extends number,
  Acc extends string = '',
  Count extends unknown[] = []
> = Count['length'] extends N
  ? Acc
  : RepeatImpl<S, N, \`\${Acc}\${S}\`, [...Count, unknown]>

/**
 * StartsWithNode - Check if string starts with substring
 *
 * @template Prefix - Prefix to check for
 *
 * @example
 * type Result = Flow<"abcdef", [Strings.StartsWith<"abc">]>
 * // Result: true
 */
export interface StartsWithNode<Prefix extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends \`\${Prefix}\${string}\`
      ? { out: true }
      : { out: false }
    : never
}

/**
 * EndsWithNode - Check if string ends with substring
 *
 * @template Suffix - Suffix to check for
 *
 * @example
 * type Result = Flow<"abcdef", [Strings.EndsWith<"def">]>
 * // Result: true
 */
export interface EndsWithNode<Suffix extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends \`\${string}\${Suffix}\`
      ? { out: true }
      : { out: false }
    : never
}

/**
 * IncludesNode - Check if string contains substring
 *
 * @template Search - Substring to search for
 *
 * @example
 * type Result = Flow<"abcdef", [Strings.Includes<"cde">]>
 * // Result: true
 */
export interface IncludesNode<Search extends string> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? T extends \`\${string}\${Search}\${string}\`
        ? { out: true }
        : { out: false }
      : { out: false }
    : never
}

/**
 * CamelCaseNode - Convert to camelCase
 *
 * @example
 * type Result = Flow<"hello_world", [Strings.CamelCase]>
 * // Result: "helloWorld"
 */
export interface CamelCaseNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: CamelCaseImpl<T> }
      : { out: never }
    : never
}

type CamelCaseImpl<S extends string> =
  S extends \`\${infer First}_\${infer Rest}\`
    ? \`\${globalThis.Lowercase<First>}\${CapitalizeWords<Rest>}\`
    : S extends \`\${infer First}-\${infer Rest}\`
      ? \`\${globalThis.Lowercase<First>}\${CapitalizeWords<Rest>}\`
      : S extends \`\${infer First} \${infer Rest}\`
        ? \`\${globalThis.Lowercase<First>}\${CapitalizeWords<Rest>}\`
        : globalThis.Uncapitalize<S>

type CapitalizeWords<S extends string> =
  S extends \`\${infer First}_\${infer Rest}\`
    ? \`\${globalThis.Capitalize<globalThis.Lowercase<First>>}\${CapitalizeWords<Rest>}\`
    : S extends \`\${infer First}-\${infer Rest}\`
      ? \`\${globalThis.Capitalize<globalThis.Lowercase<First>>}\${CapitalizeWords<Rest>}\`
      : S extends \`\${infer First} \${infer Rest}\`
        ? \`\${globalThis.Capitalize<globalThis.Lowercase<First>>}\${CapitalizeWords<Rest>}\`
        : globalThis.Capitalize<globalThis.Lowercase<S>>

/**
 * SnakeCaseNode - Convert to snake_case
 *
 * @example
 * type Result = Flow<"helloWorld", [Strings.SnakeCase]>
 * // Result: "hello_world"
 */
export interface SnakeCaseNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: SnakeCaseImpl<T> }
      : { out: never }
    : never
}

type SnakeCaseImpl<S extends string, IsFirst extends boolean = true> =
  S extends \`\${infer First}\${infer Rest}\`
    ? First extends globalThis.Uppercase<First>
      ? First extends globalThis.Lowercase<First>
        ? \`\${First}\${SnakeCaseImpl<Rest, false>}\`
        : IsFirst extends true
          ? \`\${globalThis.Lowercase<First>}\${SnakeCaseImpl<Rest, false>}\`
          : \`_\${globalThis.Lowercase<First>}\${SnakeCaseImpl<Rest, false>}\`
      : \`\${First}\${SnakeCaseImpl<Rest, false>}\`
    : S

/**
 * KebabCaseNode - Convert to kebab-case
 *
 * @example
 * type Result = Flow<"helloWorld", [Strings.KebabCase]>
 * // Result: "hello-world"
 */
export interface KebabCaseNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends string
      ? { out: KebabCaseImpl<T> }
      : { out: never }
    : never
}

type KebabCaseImpl<S extends string> =
  ReplaceImpl<SnakeCaseImpl<S>, '_', '-'>

/**
 * Exported node constructors
 */
export type Length = LengthNode
export type Split<Sep extends string> = SplitNode<Sep>
export type ToTuple = ToTupleNode
export type ToString = ToStringNode
export type ToNumber = ToNumberNode
export type Prepend<Start extends string> = PrependNode<Start>
export type Append<End extends string> = AppendNode<End>
export type Uppercase = UppercaseNode
export type Lowercase = LowercaseNode
export type Capitalize = CapitalizeNode
export type Uncapitalize = UncapitalizeNode
export type Trim<Sep extends string = ' '> = TrimNode<Sep>
export type TrimLeft<Sep extends string = ' '> = TrimLeftNode<Sep>
export type TrimRight<Sep extends string = ' '> = TrimRightNode<Sep>
export type Replace<From extends string, To extends string> = ReplaceNode<From, To>
export type Repeat<N extends number> = RepeatNode<N>
export type StartsWith<Prefix extends string> = StartsWithNode<Prefix>
export type EndsWith<Suffix extends string> = EndsWithNode<Suffix>
export type Includes<Search extends string> = IncludesNode<Search>
export type CamelCase = CamelCaseNode
export type SnakeCase = SnakeCaseNode
export type KebabCase = KebabCaseNode
`,

  '/node_modules/tlang/nodes/tuples.ts': `/**
 * Tuple transformation nodes for tlang
 *
 * Operations on tuple types (arrays with fixed length and types).
 * These are essential for list processing at the type level.
 */

import type { Node, nodeInputs } from '../core'

/**
 * MapNode - Transform each element in a tuple
 *
 * @template Fn - The transformation function to apply to each element
 *
 * @example
 * type Numbers = [1, 2, 3]
 * type Strings = Flow<Numbers, [Tuples.Map<ToString>]>
 * // Result: ["1", "2", "3"]
 */
export interface MapNode<Fn extends Node> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: MapImpl<T, Fn> }
    : never
}

type MapImpl<Tuple, Fn extends Node> =
  Tuple extends readonly [infer Head, ...infer Tail]
    ? [(Fn & { [nodeInputs]: { in: Head } })['outputs']['out'], ...MapImpl<Tail, Fn>]
    : []

/**
 * FilterNode - Keep only elements that satisfy a predicate
 *
 * @template Fn - Predicate function (should return boolean)
 *
 * @example
 * type Mixed = [1, "a", 2, "b", 3]
 * type Numbers = Flow<Mixed, [Tuples.Filter<IsNumber>]>
 * // Result: [1, 2, 3]
 */
export interface FilterNode<Fn extends Node> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: FilterImpl<T, Fn> }
    : never
}

type FilterImpl<Tuple, Fn extends Node> =
  Tuple extends readonly [infer Head, ...infer Tail]
    ? (Fn & { [nodeInputs]: { in: Head } })['outputs']['out'] extends true
      ? [Head, ...FilterImpl<Tail, Fn>]
      : FilterImpl<Tail, Fn>
    : []

/**
 * HeadNode - Get the first element of a tuple
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.Head]>
 * // Result: 1
 */
export interface HeadNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly [infer Head, ...unknown[]]
      ? { out: Head }
      : { out: never }
    : never
}

/**
 * TailNode - Get all elements except the first
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.Tail]>
 * // Result: [2, 3]
 */
export interface TailNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly [unknown, ...infer Tail]
      ? { out: Tail }
      : { out: [] }
    : never
}

/**
 * LastNode - Get the last element of a tuple
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.Last]>
 * // Result: 3
 */
export interface LastNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly [...unknown[], infer Last]
      ? { out: Last }
      : { out: never }
    : never
}

/**
 * AtNode - Get element at specific index
 *
 * @template N - Index number
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.At<1>]>
 * // Result: 2
 */
export interface AtNode<N extends number> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly unknown[]
      ? { out: T[N] }
      : { out: never }
    : never
}

/**
 * ConcatNode - Concatenate two tuples
 *
 * @template Other - The tuple to append
 *
 * @example
 * type Result = Flow<[1, 2], [Tuples.Concat<[3, 4]>]>
 * // Result: [1, 2, 3, 4]
 */
export interface ConcatNode<Other extends readonly unknown[]> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly unknown[]
      ? { out: [...T, ...Other] }
      : { out: never }
    : never
}

/**
 * ReverseNode - Reverse a tuple
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.Reverse]>
 * // Result: [3, 2, 1]
 */
export interface ReverseNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: ReverseImpl<T> }
    : never
}

type ReverseImpl<Tuple> =
  Tuple extends readonly [infer Head, ...infer Tail]
    ? [...ReverseImpl<Tail>, Head]
    : []

/**
 * ToUnionNode - Convert tuple to union
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.ToUnion]>
 * // Result: 1 | 2 | 3
 */
export interface ToUnionNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly (infer U)[]
      ? { out: U }
      : { out: never }
    : never
}

/**
 * ToIntersectionNode - Convert tuple to intersection
 *
 * @example
 * type Result = Flow<[{ a: 1 }, { b: 2 }], [Tuples.ToIntersection]>
 * // Result: { a: 1 } & { b: 2 }
 */
export interface ToIntersectionNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: ToIntersectionImpl<T> }
    : never
}

type ToIntersectionImpl<Tuple> =
  Tuple extends readonly [infer Head, ...infer Tail]
    ? Head & ToIntersectionImpl<Tail>
    : unknown

/**
 * LengthNode - Get tuple length
 *
 * @example
 * type Result = Flow<[1, 2, 3], [Tuples.Length]>
 * // Result: 3
 */
export interface LengthNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly unknown[]
      ? { out: T['length'] }
      : { out: never }
    : never
}

/**
 * IsEmptyNode - Check if tuple is empty
 *
 * @example
 * type Result = Flow<[], [Tuples.IsEmpty]>
 * // Result: true
 */
export interface IsEmptyNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly []
      ? { out: true }
      : { out: false }
    : never
}

/**
 * PrependNode - Add element to beginning
 *
 * @template Element - Element to prepend
 *
 * @example
 * type Result = Flow<[2, 3], [Tuples.Prepend<1>]>
 * // Result: [1, 2, 3]
 */
export interface PrependNode<Element> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly unknown[]
      ? { out: [Element, ...T] }
      : { out: never }
    : never
}

/**
 * AppendNode - Add element to end
 *
 * @template Element - Element to append
 *
 * @example
 * type Result = Flow<[1, 2], [Tuples.Append<3>]>
 * // Result: [1, 2, 3]
 */
export interface AppendNode<Element> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? T extends readonly unknown[]
      ? { out: [...T, Element] }
      : { out: never }
    : never
}

/**
 * JoinNode - Join tuple elements into string
 *
 * @template Sep - Separator string
 *
 * @example
 * type Result = Flow<["a", "b", "c"], [Tuples.Join<"-">]>
 * // Result: "a-b-c"
 */
export interface JoinNode<Sep extends string = ""> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: JoinImpl<T, Sep> }
    : never
}

type JoinImpl<Tuple, Sep extends string> =
  Tuple extends readonly [infer Head extends string, ...infer Tail]
    ? Tail extends readonly []
      ? Head
      : Tail extends readonly string[]
        ? \`\${Head}\${Sep}\${JoinImpl<Tail, Sep>}\`
        : Head
    : ""

/**
 * ReduceNode - Reduce tuple to single value
 *
 * @template Fn - Reducer function (acc, current) => acc
 * @template Init - Initial accumulator value
 *
 * @example
 * type Sum = Flow<[1, 2, 3], [Tuples.Reduce<Add, 0>]>
 * // Result: 6
 */
export interface ReduceNode<Fn extends Node, Init> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: ReduceImpl<T, Fn, Init> }
    : never
}

type ReduceImpl<Tuple, Fn extends Node, Acc> =
  Tuple extends readonly [infer Head, ...infer Tail]
    ? ReduceImpl<Tail, Fn, (Fn & { [nodeInputs]: { in: [Acc, Head] } })['outputs']['out']>
    : Acc

/**
 * Exported node constructors
 */
export type Map<Fn extends Node> = MapNode<Fn>
export type Filter<Fn extends Node> = FilterNode<Fn>
export type Head = HeadNode
export type Tail = TailNode
export type Last = LastNode
export type At<N extends number> = AtNode<N>
export type Concat<Other extends readonly unknown[]> = ConcatNode<Other>
export type Reverse = ReverseNode
export type ToUnion = ToUnionNode
export type ToIntersection = ToIntersectionNode
export type Length = LengthNode
export type IsEmpty = IsEmptyNode
export type Prepend<Element> = PrependNode<Element>
export type Append<Element> = AppendNode<Element>
export type Join<Sep extends string = ""> = JoinNode<Sep>
export type Reduce<Fn extends Node, Init> = ReduceNode<Fn, Init>
`,

  '/node_modules/tlang/nodes/union.ts': `/**
 * Union type transformation nodes
 *
 * Special nodes for working with union types (A | B | C).
 * Union types are distributed over these operations.
 */

import type { Node, nodeInputs } from '../core'

/**
 * UnionKeysNode - Extract all possible keys from a union
 *
 * @example
 * type Shape = { type: 'circle'; radius: number } | { type: 'square'; size: number }
 * type Keys = Flow<Shape, [UnionKeys]>
 * // Result: 'type' | 'radius' | 'size'
 */
export interface UnionKeysNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: keyof T }
    : never
}

/**
 * UnionToIntersectionNode - Convert union to intersection
 *
 * Converts A | B | C to A & B & C
 *
 * @example
 * type Union = { a: string } | { b: number }
 * type Intersection = Flow<Union, [UnionToIntersection]>
 * // Result: { a: string } & { b: number }
 */
export interface UnionToIntersectionNode extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? (T extends unknown ? (k: T) => void : never) extends (k: infer I) => void
      ? { out: I }
      : { out: never }
    : never
}

/**
 * ExcludeUnionNode - Remove specific types from a union
 *
 * @template Excluded - Types to remove from the union
 *
 * @example
 * type Mixed = string | number | null
 * type NonNull = Flow<Mixed, [ExcludeUnion<null>]>
 * // Result: string | number
 */
export interface ExcludeUnionNode<Excluded> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Exclude<T, Excluded> }
    : never
}

/**
 * ExtractUnionNode - Keep only specific types from a union
 *
 * @template Extracted - Types to extract from the union
 *
 * @example
 * type Mixed = string | number | boolean
 * type Numeric = Flow<Mixed, [ExtractUnion<number>]>
 * // Result: number
 */
export interface ExtractUnionNode<Extracted> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? { out: globalThis.Extract<T, Extracted> }
    : never
}

/**
 * UnionMapNode - Map a transformation over each member of a union
 *
 * @template Fn - Node to apply to each union member
 *
 * @example
 * type Union = 1 | 2 | 3
 * type Result = Exec<UnionMapNode<DoubleNode>, { in: Union }>
 * // { out: 2 | 4 | 6 }
 */
export interface UnionMapNode<Fn extends Node> extends Node {
  [nodeInputs]: { in: unknown }
  inputs: { in: unknown }
  outputs: this[nodeInputs]['in'] extends infer T
    ? {
        out: T extends unknown
          ? (Fn & { [nodeInputs]: { in: T } })['outputs']['out']
          : never
      }
    : never
}

/**
 * Exported node constructors
 */
export type UnionKeys = UnionKeysNode
export type UnionToIntersection = UnionToIntersectionNode
export type ExcludeUnion<Excluded> = ExcludeUnionNode<Excluded>
export type ExtractUnion<Extracted> = ExtractUnionNode<Extracted>
export type UnionMap<Fn extends Node> = UnionMapNode<Fn>
`,
}

/**
 * Package.json for tlang module resolution
 */
export const TLANG_PACKAGE_JSON = `{
  "name": "tlang",
  "version": "0.1.0",
  "main": "./index.ts",
  "types": "./index.ts",
  "exports": {
    ".": "./index.ts",
    "./*": "./*"
  }
}`

/**
 * Load tlang sources into a virtual file system map
 */
export function loadTLangIntoVFS(fsMap: Map<string, string>): void {
  // Add all source files
  for (const [path, content] of Object.entries(TLANG_SOURCES)) {
    fsMap.set(path, content)
  }

  // Add package.json
  fsMap.set('/node_modules/tlang/package.json', TLANG_PACKAGE_JSON)
}
